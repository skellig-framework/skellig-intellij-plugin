{
  parserClass="org.skellig.plugin.parser.testdata.SkelligTestDataParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="SkelligTestData"
  psiImplClassSuffix="Impl"
  psiPackage="org.skellig.plugin.language.testdata.psi"
  psiImplPackage="org.skellig.plugin.language.testdata.psi.impl"

  elementTypeHolderClass="org.skellig.plugin.language.testdata.psi.SkelligTestDataTypes"
  elementTypeClass="org.skellig.plugin.language.testdata.psi.SkelligTestDataElementType"
  tokenTypeClass="org.skellig.plugin.language.testdata.psi.SkelligTestDataTokenType"

  psiImplUtilClass="org.skellig.plugin.language.testdata.psi.SkelligTestDataUtil"

   tokens = [
          key ='regex:[^:=\ \n\t\f\\]'
          number='regexp:\d+(\.\d*)?'
          symbols = 'regexp:[;:+|&"?#!\^@\\*\w,><_-]+'
          space = 'regexp:\s+'
          comment='regexp://.*'
          block_comment='regexp:/\*([^*]|\*+[^*/])*(\*+/)?'
          string="regexp:('([^'\\]|\\.)*'|\"([^\"\\]|\\.)*\")"
          separator="="
          parameterOpenBracket='${'
          objectOpenBracket='{'
          objectCloseBracket='}'
          arrayOpenBracket='['
          arrayCloseBracket=']'
          functionOpenBracket='('
          functionCloseBracket=')'
          dot='.'
      ]
}

root ::= definition
definition ::= testDefinition*
testDefinition ::= name functionOpenBracket string functionCloseBracket objectOpenBracket testBody objectCloseBracket
{
 mixin="org.skellig.plugin.language.testdata.psi.impl.SkelligTestDataNamedElementImpl"
 implements="org.skellig.plugin.language.testdata.psi.SkelligTestDataNamedElement"
 methods=[getName getNameIdentifier]
}
testBody ::= statement*
statement ::= idDef | variablesDef | dataDef | validationDef | dataStatement
dataStatement ::= parameterDef | fieldDefinition | objectDefinition | arrayDef | complexFunctionsDef | jsonFunctionsDef

idDef ::= id separator valueDef

fieldDefinition ::= symbols separator ( parameterDef | functionDef | valueDef )

parameterDef ::= parameterOpenBracket ( functionDef | valueDef | keywords) objectCloseBracket (dot symbols bracketsDef?)*

objectDefinition ::= symbols anonymousObjectDefinition

anonymousObjectDefinition ::= objectOpenBracket statement* objectCloseBracket

complexFunctionsDef ::= (if|template|json|csv) (objectOpenBracket|arrayOpenBracket) statement* (objectCloseBracket|arrayCloseBracket)
jsonFunctionsDef ::= json (objectOpenBracket|arrayOpenBracket) (symbols | anonymousObjectDefinition | statement)* (objectCloseBracket|arrayCloseBracket)

functionDef ::= symbols functionBracketsDef*
private functionBracketsDef ::= bracketsDef propCallDef*
private bracketsDef ::= functionOpenBracket (functionDef|parameterDef|valueDef|propCallDef|keywords)* functionCloseBracket
private propCallDef ::= (dot(symbols|bracketsDef|keywords))

arrayDef ::= symbols arrayOpenBracket (symbols | anonymousObjectDefinition | dataStatement)* arrayCloseBracket

variablesDef ::= variables objectOpenBracket dataStatement* objectCloseBracket
dataDef ::= (message|request|body|payload) (objectOpenBracket|arrayOpenBracket) dataStatement* (objectCloseBracket|arrayCloseBracket)

validationDef ::= validationObjectDef | validationArray
private validationObjectDef ::= (validate|assert|'expected response') objectOpenBracket (dataStatement | fromTestDef)* objectCloseBracket
private validationArray ::= (validate|assert|'expected response') arrayOpenBracket symbols* arrayCloseBracket
fromTestDef ::= fromTest separator valueDef

valueDef ::= ( number | symbols | string )

keywords ::= (name|id|variables|message|payload|request|body|validate|assert|if|template|json|csv|fromTest|'expected response')


/*
name("test (.*) 1") {

variables {
 f = 1
}

message {
  bb {
    gg {
      f1 = 100.4
      f2 = now().gg.bb
      f5 = get(hh)
      g = 1
      f5 = get(nn).fs_f(${gg}).json_path("a/b/c")
    }
    f3 = get(g).ff.gg.sdg
    f4 = "f 2 3"
  }
}

expected response {
  from_test = 12
  msg {
      if {
        condition = "${srv.usr} == usr && ($1 < 1 || $2 > 10)"
        then {
          json {
          }
        }
      }
   }
   v = 132
}

arr [
 {
   a {
    b [
      bbb
      cc + c c
    ]
   }
   c = d
 }
 {
    a = "b"
    c = d
  }
]
field1 = d1
f2 = 4-5
f_3 = 4.5
any = f42_-bb||&?c;v:5+3#@!*^
str = "f _ d"
}


name("Send a message with if statement") {
  id = if_test_1
  variables {
        //get function with extraction cannot be embedded into regex-comparator at the moment
        score = get(step1).(variable.score)
  }
  receiver = user1
  message {
     f1 = 0
     if {
        condition = '${num} == 1'
        then {
          f2 = 11
          f3 [
          ggg
          ${gr}
          {
            hh = 123
            gg = get().gg
            vv = 55.32
          }
          ]
          receivedBy = ${key1_get(id)}.json_path("a/b/c").size_${k}
          k = 10
          hh = ${id}.size
          b = ${key1}
          gg = now()
        }
        else {
          f2 = 2
          f3 = 22
        }
     }
  }

}

// This is a comment.
name(execute \w command) {
   variables {
      args = "-a 1 -b 2"
      score = get(step1).(variable.score)
   }

   payload {
      json [
        ff
        weg
      ]
   }

   expected response [
     aff
     ewgwe
   ]
}

*/